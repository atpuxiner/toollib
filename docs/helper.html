<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <style type="text/css">
        html, body {height: 100%; padding: 0; margin: 0;}
        .top {
            z-index: 999;
            position: fixed;
            top: 0;
            right: 10%;
            left: 10%;
            height: 155px;
            background-color: darkseagreen;
            text-align: center;
        }
        .ahead {
            font-size: 18px;
        }
        .main {
            position: relative;
            width: 80%;
            margin: 0 auto;
            box-shadow: 5px -5px 10px 10px darkgray;
            background-color: azure;
        }
        .docs {
            position: relative;
            bottom: 22px;
            font-size: 16px;
            padding: 0 10px;
        }
    </style>
    <title>toollib 官方文档</title>
</head>
<body>
    <div class="top">
        <h1>toollib 官方文档</h1>
        <div class="ahead"><pre>
	更多功能正在完善...
	更多功能正在完善...
	更多功能正在完善...</pre></div>
        <HR>
    </div>
    <div class="main">
        <div class="docs">
            <br><br><br><br><br><br><br><br><br>
            
<h2><i>toollib.autodriver</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/1/18 21:05
@abstract web驱动
@description
@history
</pre>
---------------------------------

<h3><i>chromedriver</i></h3><pre>
    自动下载谷歌驱动（注：若指定目录存在与浏览器版本一致的驱动则会跳过）

    e.g.::

        import time

        from selenium import webdriver
        from selenium.webdriver.chrome.service import Service
        from selenium.webdriver.common.by import By
        from toollib import autodriver

        # 自动下载驱动，默认下载本地浏览器对应的版本（各参数可自行指定）
        driver_path = autodriver.chromedriver()
        # 以下为selenium模拟操作
        driver = webdriver.Chrome(service=Service(driver_path))
        driver.get('https://www.baidu.com')
        driver.find_element(By.ID, 'chat-textarea').send_keys('python toollib')
        driver.find_element(By.ID, 'chat-submit-button').click()
        time.sleep(29)
        driver.quit()

        +++++[更多详见参数或源码]+++++

    :param driver_dir: 驱动目录（默认当前执行目录）
    :param platform: 平台（支持：['win32', 'win64', 'mac64', 'mac-arm64', 'linux64']）
    :param browser_version: 浏览器版本
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.codec</i></h2><pre>
@author axiner
@version v1.0.0
@created 2024/2/28 10:20
@abstract 编码
@description
@history
</pre>
---------------------------------

<h3><i>detect_encoding</i></h3><pre>
    检测编码

    e.g.::

        enc = detect_encoding('foo.txt')

        +++++[更多详见参数或源码]+++++

    :param data_or_path: 数据或路径
    :param size: 大小
    :param default: 默认值
    :return:
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.decorator</i></h2><pre>
@author axiner
@version v1.0.0
@created 2021/12/14 20:28
@abstract 装饰器
@description
@history
</pre>
---------------------------------

<h3><i>catch_exception</i></h3><pre>
    捕获异常

    e.g.::

        @decorator.catch_exception()
        def foo():
            pass

        +++++[更多详见参数或源码]+++++

    :param is_raise: 是否raise
    :param default: 默认值
    :param exception: 异常类
    :param errmsg: 异常信息
    :return:
    </pre>

<h3><i>timer</i></h3><pre>
    计时器

    e.g.::

        @decorator.timer()
        def foo():
            pass

        +++++[更多详见参数或源码]+++++

    :param func:
    :return:
    </pre>

<h3><i>sys_required</i></h3><pre>
    系统要求

    e.g.::

        @decorator.sys_required()
        def foo():
            pass

        +++++[更多详见参数或源码]+++++

    注：当前系统名称：优先从环境变量获取，其次自动获取（以防自动获取不精确，则可手动设置）

    :param supported_sys: 支持的系统（正则表达式）
    :param errmsg: 匹配失败信息
    :param is_raise: 是否raise
    :return:
    </pre>

<h3><i>to_async</i></h3><pre>
    转为异步函数

    e.g.::

        @decorator.to_async()
        def foo():
            pass

        +++++[更多详见参数或源码]+++++

    :param pool_type: 池的类型（['thread', 'process']）
    :param max_workers: 池的最大工作数
    :return:
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.guid</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/7/30 16:07
@abstract 全局唯一id
@description
@history
</pre>
---------------------------------

<h3><i>SnowFlake</i></h3><pre>
    雪花算法（全局唯一id）

    # 最早是Twitter公司在其内部用于分布式环境下生成唯一ID

    # Twitter's Snowflake algorithm implementation which is used to generate distributed IDs.

    # https://github.com/twitter-archive/snowflake/blob/snowflake-2010/src/main/scala/com/twitter/service/snowflake/IdWorker.scala

    e.g.::

        from toollib.guid import SnowFlake
        snow_cli = SnowFlake()
        uid = snow_cli.gen_uid()

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>SnowFlake.gen_uid</i></h3><pre>
        生成唯一id
        :param to_str: 是否转为字符串(可覆盖cls中的to_str)
        :return:
        </pre>

<h3><i>RedisUid</i></h3><pre>
    全局唯一id，基于redis实现（可用于分布式）

    e.g.::

        from toollib.guid import RedisUid

        ruid_cli = RedisUid(redis_cli, prefix='ABC')
        uid = ruid_cli.gen_uid()

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>RedisUid.gen_uid</i></h3><pre>
        生成唯一id
        :param seq_step: 序列步长，默认为1
        :return:
        </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.kvalue</i></h2><pre>
@author axiner
@version v1.0.0
@created 2021/12/18 22:21
@abstract key-value容器（基于sqlite3）
@description
@history
</pre>
---------------------------------

<h3><i>KValue</i></h3><pre>
    key - value 容器
    - key 支持类型：
        - str
    - value 支持类型：
        - str
        - list
        - dict
        - int
        - float
        - bool
        - NoneType

    e.g.::

        # 创建一个 kvalue 实例
        kv = KValue()

        # 增删改查等操作
        kv.set(key='name', value='xxx')
        kv.get(key='name')
        kv.exists(key='name')
        kv.delete(key='name')
        ...

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>KValue.clear</i></h3><pre>
        清除所有 key - value
        :return:
        </pre>

<h3><i>KValue.clear_expired</i></h3><pre>
        清除已过期的 key - value
        :return:
        </pre>

<h3><i>KValue.count</i></h3><pre>
        数量
        :return:
        </pre>

<h3><i>KValue.delete</i></h3><pre>
        删除 key
        :param key:
        :return:
        </pre>

<h3><i>KValue.execute</i></h3><pre>
        执行
        :param sql: 语句
        :param parameters: 参数
        :return:
        </pre>

<h3><i>KValue.executemany</i></h3><pre>
        执行
        :param sql: 语句
        :param parameters: 参数
        :return:
        </pre>

<h3><i>KValue.exists</i></h3><pre>
        检测 key 是否存在
        :param key:
        :return:
        </pre>

<h3><i>KValue.expire</i></h3><pre>
        设置 key 的过期时间
        :param key:
        :param expire: 默认为 0.0（表不设置过期时间）
        :return:
        </pre>

<h3><i>KValue.fetchall</i></h3><pre>
        查询
        :param sql: 语句
        :param parameters: 参数
        :return:
        </pre>

<h3><i>KValue.fetchone</i></h3><pre>
        查询
        :param sql: 语句
        :param parameters: 参数
        :return:
        </pre>

<h3><i>KValue.get</i></h3><pre>
        获取 key 的 value
        :param key: 键
        :param raise_expire: 是否过期异常
        :param return_expire: 是否返回过期时间
        :return:
        </pre>

<h3><i>KValue.items</i></h3><pre>
        获取所有 item
        :return:
        </pre>

<h3><i>KValue.keys</i></h3><pre>
        获取所有 key
        :return:
        </pre>

<h3><i>KValue.remove</i></h3><pre>
        移除实例的数据文件
        :return:
        </pre>

<h3><i>KValue.set</i></h3><pre>
        设置 kye - value
        :param key: 键
        :param value: 值
        :param expire: 默认为 0.0（表不设置过期时间）
        :return:
        </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.locker</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/10/28 14:03
@abstract 锁
@description
@history
</pre>
---------------------------------

<h3><i>Locker</i></h3><pre>
    锁，基于redis的分布式锁

    e.g.::

        a = 0
        locker = Locker(redis_cli)  # 创建锁实例
        if locker.acquire(acquire_timeout=2):  # 获取锁
            for i in range(10):
                a += 1
                print(f'a: {a}')
            locker.release()  # 释放锁

        # 另：with方式
        a = 0
        locker = Locker(redis_cli, acquire_timeout=2)
        with locker:
            if locker.is_lock:  # 若获取锁
                for i in range(10):
                    a += 1
                    print(f'a: {a}')

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>Locker.acquire</i></h3><pre>
        获取锁
        :param acquire_timeout: 获取锁的超时时间
        :param timeout: 锁的过期时间
        :return:
        </pre>

<h3><i>Locker.release</i></h3><pre>
        释放锁
        :return:
        </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.log</i></h2><pre>
@author axiner
@version v1.0.0
@created 2023/5/20 13:19
@abstract 日志-logging
@description
@history
</pre>
---------------------------------

<h3><i>LogFormatter</i></h3><pre>暂无文档</pre>

<h3><i>LogFormatter.format</i></h3><pre>暂无文档</pre>

<h3><i>LogFormatter.formatException</i></h3><pre>
        Format and return the specified exception information as a string.

        This default implementation just uses
        traceback.print_exception()
        </pre>

<h3><i>LogFormatter.formatMessage</i></h3><pre>暂无文档</pre>

<h3><i>LogFormatter.formatStack</i></h3><pre>
        This method is provided as an extension point for specialized
        formatting of stack information.

        The input data is a string as returned from a call to
        :func:`traceback.print_stack`, but with the last trailing newline
        removed.

        The base implementation just returns the value passed in.
        </pre>

<h3><i>LogFormatter.formatTime</i></h3><pre>
        Return the creation time of the specified LogRecord as formatted text.

        This method should be called from format() by a formatter which
        wants to make use of a formatted time. This method can be overridden
        in formatters to provide for any specific requirement, but the
        basic behaviour is as follows: if datefmt (a string) is specified,
        it is used with time.strftime() to format the creation time of the
        record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
        The resulting string is returned. This function uses a user-configurable
        function to convert the creation time to a tuple. By default,
        time.localtime() is used; to change this for a particular formatter
        instance, set the 'converter' attribute to a function with the same
        signature as time.localtime() or time.gmtime(). To change it for all
        formatters, for example if you want all logging times to be shown in GMT,
        set the 'converter' attribute in the Formatter class.
        </pre>

<h3><i>LogFormatter.usesTime</i></h3><pre>
        Check if the format uses the creation time of the record.
        </pre>

<h3><i>init_logger</i></h3><pre>
    初始化日志器

    e.g.::

        # 初始化
        from toollib import log

        logger = log.init_logger(__name__)
        logger.info("hello")

        # 其他模块调用建议
        import logging

        logger = logging.getLogger(__name__)
        logger.info("hello")

        +++++[更多详见参数或源码]+++++

    :param name: 名称
    :param level: 日志等级
    :param fmt: 日志格式
    :param datefmt: 时间格式
    :param msecfmt: 时间毫秒格式
    :param request_id_var: 请求id变量
    :param fmt_with_request_id: 带request_id的日志格式
    :param serialize: 序列化
    :param formatter: 格式化实例
    :param clear_handlers: 清除handlers
    :param enable_console: 开启控制台日志
    :param enable_file: 开启文件日志
    :param basedir: 日志基目录
    :param access_name: access名称
    :param error_name: error名称
    :param name_with_pid: 名称带pid
    :param encoding: 编码
    :param rotation: 轮转方式
    :param backup_count: 轮转备份数
    :param when: 轮转时间
    :param interval: 轮转间隔
    :param max_bytes: 轮转最大字节
    :param propagate: 向上传播
    :param enqueue: 启用队列
    :param queue_maxsize: 队列最大容量
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.logu</i></h2><pre>
@author axiner
@version v1.0.0
@created 2023/5/20 13:19
@abstract 日志-loguru
@description
@history
</pre>
---------------------------------

<h3><i>LogFormatter</i></h3><pre>暂无文档</pre>

<h3><i>LogInterception</i></h3><pre>暂无文档</pre>

<h3><i>LogInterception.acquire</i></h3><pre>
        Acquire the I/O thread lock.
        </pre>

<h3><i>LogInterception.addFilter</i></h3><pre>
        Add the specified filter to this handler.
        </pre>

<h3><i>LogInterception.close</i></h3><pre>
        Tidy up any resources used by the handler.

        This version removes the handler from an internal map of handlers,
        _handlers, which is used for handler lookup by name. Subclasses
        should ensure that this gets called from overridden close()
        methods.
        </pre>

<h3><i>LogInterception.createLock</i></h3><pre>
        Acquire a thread lock for serializing access to the underlying I/O.
        </pre>

<h3><i>LogInterception.emit</i></h3><pre>暂无文档</pre>

<h3><i>LogInterception.filter</i></h3><pre>
        Determine if a record is loggable by consulting all the filters.

        The default is to allow the record to be logged; any filter can veto
        this and the record is then dropped. Returns a zero value if a record
        is to be dropped, else non-zero.

        .. versionchanged:: 3.2

           Allow filters to be just callables.
        </pre>

<h3><i>LogInterception.flush</i></h3><pre>
        Ensure all logging output has been flushed.

        This version does nothing and is intended to be implemented by
        subclasses.
        </pre>

<h3><i>LogInterception.format</i></h3><pre>
        Format the specified record.

        If a formatter is set, use it. Otherwise, use the default formatter
        for the module.
        </pre>

<h3><i>LogInterception.get_name</i></h3><pre>暂无文档</pre>

<h3><i>LogInterception.handle</i></h3><pre>
        Conditionally emit the specified logging record.

        Emission depends on filters which may have been added to the handler.
        Wrap the actual emission of the record with acquisition/release of
        the I/O thread lock. Returns whether the filter passed the record for
        emission.
        </pre>

<h3><i>LogInterception.handleError</i></h3><pre>
        Handle errors which occur during an emit() call.

        This method should be called from handlers when an exception is
        encountered during an emit() call. If raiseExceptions is false,
        exceptions get silently ignored. This is what is mostly wanted
        for a logging system - most users will not care about errors in
        the logging system, they are more interested in application errors.
        You could, however, replace this with a custom handler if you wish.
        The record which was being processed is passed in to this method.
        </pre>

<h3><i>LogInterception.release</i></h3><pre>
        Release the I/O thread lock.
        </pre>

<h3><i>LogInterception.removeFilter</i></h3><pre>
        Remove the specified filter from this handler.
        </pre>

<h3><i>LogInterception.setFormatter</i></h3><pre>
        Set the formatter for this handler.
        </pre>

<h3><i>LogInterception.setLevel</i></h3><pre>
        Set the logging level of this handler.  level must be an int or a str.
        </pre>

<h3><i>LogInterception.set_name</i></h3><pre>暂无文档</pre>

<h3><i>init_logger</i></h3><pre>
    初始化日志器

    e.g.::

        # 初始化
        from toollib import logu

        logger = logu.init_logger(__name__)
        logger.info("hello")

        # 其他模块调用建议
        from loguru import logger

        logger.info("hello")

        +++++[更多详见参数或源码]+++++

    :param name: 名称（无用）
    :param level: 日志等级
    :param fmt: 日志格式
    :param datefmt: 时间格式
    :param msecfmt: 时间毫秒格式
    :param request_id_var: 请求id变量
    :param fmt_with_request_id: 带request_id的日志格式
    :param serialize: 序列化
    :param formatter: 格式化实例
    :param clear_handlers: 清除handlers
    :param enable_console: 开启控制台日志
    :param enable_file: 开启文件日志
    :param basedir: 日志基目录
    :param access_name: access名称
    :param error_name: error名称
    :param name_with_pid: 名称带pid
    :param encoding: 编码
    :param rotation: 轮转方式
    :param retention: 保留策略
    :param compression: 压缩方式
    :param enqueue: 启用队列
    :param backtrace: 回溯
    :param diagnose: 诊断
    :param catch: 捕获
    :param interception: 拦截器
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.pyd</i></h2><pre>
@author axiner
@version v1.0.0
@created 2023/4/7 15:14
@abstract pyd
@description
@history
</pre>
---------------------------------

<h3><i>PydPacker</i></h3><pre>
    pyd打包器

    e.g.::

        packer = PydPacker(src=r'D:\pyproj', exclude='main.py')
        packer.run()

        - 注：
            - 自动跳过：__init__.py，空文件，只存在注释的文件，当然还有非py文件
            - 排除编译：正则表达式
                - 文件夹加正斜杠'/'即可，如：tests/, tests/a/
                - 多个则用'|'隔开，如：main.py|tests/
                - 项目的入口文件一般是不编译的，排除即可
            - 若编译不成功或编译后执行不成功：
                - 规范代码，确保代码的正确性与严谨性
                - 编译失败，目录下会保留对应的源文件
                - 执行环境，需要与编译时的环境一致
            - 输出：目录（源+扩展后缀），该目录与src结构一致

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>PydPacker.run</i></h3><pre>
        执行
        :return:
        </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.rediscli</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/10/28 14:23
@abstract redis客户端
@description
@history
</pre>
---------------------------------

<h3><i>RedisCli</i></h3><pre>
    redis客户端

    e.g.::

        # 创建
        redis_cli = RedisCli(host='127.0.0.1', max_connections=100)

        # 使用方式1：标准用法（推荐）
        r = redis_cli.connection()
        print(r.get("name"))
        print(r.get("age"))
        r.close()

        # 使用方式2：代理调用-每次创建新连接（不推荐）
        print(redis_cli.get("name"))
        print(redis_cli.get("age"))

        # 使用方式3：上下文管理器（推荐）
        with redis_cli.connection() as r:
            print(r.get("name"))

        # 使用方式4：上下文管理器（简洁写法）
        with redis_cli as r:
            print(r.get("name"))

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>RedisCli.connection</i></h3><pre>
        创建连接
        :return:
        </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.regexp</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/2/8 20:37
@abstract 正则表达式
@description
    有以下正则表达式：
        1）中文，regexp.zh
        2）表情：regexp.emoji

        3）手机号：regexp.phone
        4）座机号（有‘-’）：regexp.landline
        5）座机号（‘-’可有可无）：regexp.landline2
        6）手机号和座机号：regexp.phone_and_landline

        7）邮箱：regexp.email
        8）邮箱（可含中文字符）：regexp.email_contain_zh

        9）ipv4: regexp.ipv4
        10）ipv4（粗匹配）: regexp.ipv4_simple
        11）ipv6（粗匹配）: regexp.ipv6_simple

        12）url: regexp.url
@history
</pre>


<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.useragent</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/2/8 20:36
@abstract 用户代理
@description
    有以下属性：
        1）uas列表1000条：useragent.uas
        2）从1000条uas中随机选1条：useragent.random_ua()
        3）生成uas: useragent.gen_uas()
@history
</pre>
---------------------------------

<h3><i>random_ua</i></h3><pre>
    随机User-Agent

    e.g.::

        ua = useragent.random_ua()

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>gen_uas</i></h3><pre>
    生成User-Agent

    e.g.::

        uas = useragent.gen_uas()

        +++++[更多详见参数或源码]+++++

    :param max_len: 最大长度（数量）
    :return:
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.validator</i></h2><pre>
@author axiner
@version v1.0.0
@created 2022/3/5 0:03
@abstract 校验器
@description
@history
</pre>
---------------------------------

<h3><i>Attr</i></h3><pre>
    属性校验（数据描述符）

    e.g.::

        请查看数据描述符中数据校验.....

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>choicer</i></h3><pre>
    选择校验（校验通过时返回obj）

    e.g.::

        flag = 1
        flag = validator.choicer(flag, choices=[1,2,3], lable='标识')

        # res: 若校验不通过则报异常

        +++++[更多详见参数或源码]+++++

    :param obj: 对象
    :param choices: 可选范围
    :param lable: 标签
    :param errmsg: 不在可选范围时报错信息
    :return:
    </pre>

<h3><i>pyv</i></h3><pre>
    python版本校验

    e.g.::

        pyv = validator.pyv(min_v='3.7')

        # res: 若校验不通过则报异常

        +++++[更多详见参数或源码]+++++

    :param min_v: 最小版本号（包含）
    :param max_v: 最大版本号（不包含）
    :return:
    </pre>
<br>++++++++++++++++++++++这是分隔线++++++++++++++++++++++
<h2><i>toollib.utils</i></h2><pre>
@author axiner
@version v1.0.0
@created 2021/12/18 22:20
@abstract 实用工具
@description
@history
</pre>
---------------------------------

<h3><i>Singleton</i></h3><pre>
    单例模式

    e.g.::

        # 使类A变为单例模式
        class A(metaclass=Singleton):
            pass

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>Chars</i></h3><pre>
    字符

    e.g.::

        # 比如获取小写字母
        lowercases = utils.Chars.lowercases

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>now2timestr</i></h3><pre>
    获取当前时间字符串

    e.g.::

        now = utils.now2timestr()

        +++++[更多详见参数或源码]+++++

    :param fmt: 格式化
    :param tzname: 时区名称
    :return:
    </pre>

<h3><i>timestr2time</i></h3><pre>
    时间字符串转时间对象或时间戳(unit若存在)

    e.g.::

        dt = utils.timestr2time('2021-12-12')

        +++++[更多详见参数或源码]+++++

    :param timestr: 时间字符串
    :param fmt: 格式化
    :param unit: 单位（fs-浮点型秒, s-秒，ms-毫秒，us-微秒，ns-纳秒）
    :param tzname: 时区名称
    :return:
    </pre>

<h3><i>now2timestamp</i></h3><pre>
    获取当前时间戳

    e.g.::

        timestamp = utils.now2timestamp()

        +++++[更多详见参数或源码]+++++

    :param unit: 单位（fs-浮点型秒, s-秒，ms-毫秒，us-微秒，ns-纳秒）
    :param tzname: 时区名称
    :return:
    </pre>

<h3><i>timestamp2time</i></h3><pre>
    时间戳转时间对象或时间字符串(fmt若存在)

    e.g.::

        dt = utils.timestamp2time()

        +++++[更多详见参数或源码]+++++

    :param timestamp: 时间戳
    :param unit: 单位（s-秒，ms-毫秒，us-微秒，ns-纳秒）
    :param fmt: 格式化
    :param tzname: 时区名称
    :return:
    </pre>

<h3><i>timerange</i></h3><pre>
    时间范围
        - fmt存在，返回时间字符串
        - fmt不存在 & unit存在，返回时间戳
        - fmt不存在 & unit不存在，返回时间对象

    e.g.::

        tr = utils.timerange('2021-12-12')

        +++++[更多详见参数或源码]+++++

    :param start: 开始
    :param end: 结束
    :param fmt: 格式化
    :param unit: 单位（fs-浮点型秒, s-秒，ms-毫秒，us-微秒，ns-纳秒）
    :return:
    </pre>

<h3><i>home</i></h3><pre>
    家目录

    e.g.::

        h = utils.home()

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>sysname</i></h3><pre>
    系统名称

    e.g.::

        s = utils.sysname()

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>RedirectStd12ToNull</i></h3><pre>
    重定向标准输出错误到null

    e.g.::

        with RedirectStd12ToNull():
            # 你要重定向的代码块

        # 另：取消stderr的重定向
        with RedirectStd12ToNull(is_stderr=False):
            # 你要重定向的代码块

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>VersionCmper</i></h3><pre>
    版本比较

    e.g.::

        from toollib.utils import VersionCmper

        ver1 = VersionCmper("1.0.1")
        ver2 = VersionCmper("1.0.2")
        print(ver1 > ver2)  # Out: False

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>listfile</i></h3><pre>
    文件列表

    e.g.::

        # 比如获取某目录下的.py文件
        src_dir = 'D:/tmp'
        flist = utils.listfile(src_dir, pattern='*.py')

        +++++[更多详见参数或源码]+++++

    :param src: 源目录
    :param pattern: 匹配模式
    :param is_str: 是否返回字符串（True: 若为路径返回字符串，False: 若为路径返回Path类型）
    :param is_name: 是否获取文件名（True: 返回文件路径，False: 返回文件名）
    :param is_r: 是否递规查找
    :return:
    </pre>

<h3><i>decompress</i></h3><pre>
    解压文件

    e.g.::

        # 比如解压某目录下的.zip文件
        src = 'D:/tmp'
        count = utils.decompress(src, pattern='*.zip')

        +++++[更多详见参数或源码]+++++

    :param src: 源目录或文件
    :param dst: 目标目录
    :param pattern: 匹配模式（当src为目录时生效，默认匹配所有支持的压缩包）
    :param is_r: 是否递规查找（当src为目录时生效）
    :param is_raise: 是否抛异常
    :return: count（解压数量）
    </pre>

<h3><i>writetemp</i></h3><pre>
    写入临时文件

    e.g.::

        filepath = utils.writetemp(content)

        +++++[更多详见参数或源码]+++++

    :param content: 内容
    :param suffix: 后缀
    :param kwargs: kwargs
    :return:
    </pre>

<h3><i>gen_leveldirs</i></h3><pre>
    生成层级目录

    e.g.::

        tag = "abcdef"
        dirs = utils.gen_leveldirs(tag)

        +++++[更多详见参数或源码]+++++

    :param tag: 目标
    :param number: 数量
    :param length: 长度
    :param is_keep_extra: 是否保留额外的
    :param prefix: 前级
    :param sep: 分隔符
    :return:
    </pre>

<h3><i>map_jsontype</i></h3><pre>
    映射json类型

    e.g.::

        typename = "str"
        mt = utils.map_jsontype(typename)

        +++++[更多详见参数或源码]+++++

    :param typename: 类型名称
    :param is_title: 是否首字母大写
    :param is_keep_integer: 是否保留integer
    :return:
    </pre>

<h3><i>pkg_lver</i></h3><pre>
    包的最新版本

    e.g.::

        v = utils.pkg_lver("toollib")

        +++++[更多详见参数或源码]+++++

    :param pkg_name: 包名
    :return:
    </pre>

<h3><i>localip</i></h3><pre>
    本地ip

    e.g.::

        ip = utils.localip()
        ip = utils.localip(["8.8.4.4", "1.1.1.1"])  # 使用自定义DNS

        +++++[更多详见参数或源码]+++++

    :param dns_servers: dns服务
    :return:
    </pre>

<h3><i>get_cls_attrs</i></h3><pre>
    获取类属性

    e.g.::

        # 获取类属性
        class A:

            def foo(self):
                cls_attrs = get_cls_attrs(A)

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>parse_variable</i></h3><pre>
    解析变量

    e.g.::

        value = utils.parse_variable(k="name", v_type=str, v_from=os.environ)

        +++++[更多详见参数或源码]+++++

    :param k: 键
    :param v_type: 值类型
    :param v_from: 值来源
    :param v_convert: 值转换
    :param v_invalid: 值无效
    :param default: 默认值
    :param sep: 分隔符，针对list、tuple、set、dict
    :param kv_sep: 键值分隔符，针对dict
    :param is_raise: 是否raise
    :return: 转换后的值
    </pre>

<h3><i>VFrom</i></h3><pre>暂无文档</pre>

<h3><i>VFrom.get</i></h3><pre>暂无文档</pre>

<h3><i>VConvert</i></h3><pre>暂无文档</pre>

<h3><i>copytree</i></h3><pre>
    复制目录树

    e.g.::

        copytree(src=r"D:/myproj", dst=r"D:/myproj-bak", ignore_regex=r"^logs($|/)")

    :param src: 源目录路径
    :param dst: 目标目录路径
    :param ignore_regex: 忽略正则表达式（使用'/'作为路径分隔符）
    :param dirs_exist_ok: 是否允许目标目录已存在
    :param copy_function: 文件复制函数（默认 shutil.copy2）
    </pre>

<h3><i>detect_encoding</i></h3><pre>
    检测编码

    e.g.::

        encoding = utils.detect_encoding('中中中文'.encode('gbk'))

        +++++[更多详见参数或源码]+++++

    :param data_or_path: 数据或路径
    :param size: 大小
    :param retry_size: 重试大小
    :param confidence: 置信度
    :param default: 默认值
    :return:
    </pre>

<h3><i>read_csv</i></h3><pre>
    读取 csv 文件

    e.g.::

        for idx, row in utils.read_csv(r'E:	mp.csv'):
            print(idx, row)

        +++++[更多详见参数或源码]+++++

    :param filepath: 文件路径
    :param column_names: 列名称
    :param min_rows: 最小行
    :param max_rows: 最大行
    :param encoding: 编码
    :return:
    </pre>

<h3><i>read_xlsx</i></h3><pre>
    读取 xlsx 文件

    e.g.::

        for idx, row in read_xlsx(r'E:	mp.xlsx'):
            print(idx, row)

    :param filepath: 文件路径
    :param column_names: 列名称
    :param min_rows: 最小行
    :param max_rows: 最大行
    :param sheet_name: 工作表
    :return:
    </pre>

<h3><i>split_csv</i></h3><pre>
    分割 csv 文件

    e.g.::

        for p in utils.split_csv(r'E:	mp.csv'):
            print(p)

        +++++[更多详见参数或源码]+++++

    :param filepath: 文件路径
    :param max_rows: 最大行数
    :param max_files: 最大文件数
    :param output_dir: 输出目录
    :param part_sep: part分隔符
    :param part_prefix: part前缀
    :param part_zfill: part补零数
    :param part_pos: part编号位置
    :param encoding: 编码
    :yields:
    </pre>

<h3><i>split_xlsx</i></h3><pre>
    分割 xlsx 文件

    e.g.::

        for p in utils.split_xlsx(r'E:	mp.xlsx'):
            print(p)

        +++++[更多详见参数或源码]+++++

    :param filepath: 文件路径
    :param max_rows: 最大行数
    :param max_files: 最大文件数
    :param output_dir: 输出目录
    :param part_sep: part分隔符
    :param part_prefix: part前缀
    :param part_zfill: part补零数
    :param part_pos: part编号位置
    :param sheet_name: 工作表
    :yields:
    </pre>

<h3><i>ConfigLoader</i></h3><pre>
    配置加载器

    e.g.::

        class Config(ConfigLoader):
            xxx1: int = 1
            xxx2: str = "abc"


        config = Config(dotenv_path="./.env", yaml_path="./xxx.yaml")
        config.load()  # 加载
        print(config.xxx1)

        +++++[更多详见参数或源码]+++++
    </pre>

<h3><i>ConfigLoader.load</i></h3><pre>
        加载
        :param prefer_env: 优先env
        :param clear_cache: 清除缓存
        :param v_converts: 值转换
        :param v_invalid: 值无效
        :param sep: 分隔符，针对list、tuple、set、dict
        :param kv_sep: 键值分隔符，针对dict
        :param is_raise: 是否raise
        :return:
        </pre>

<h3><i>ConfigLoader.load_yaml</i></h3><pre>暂无文档</pre>

        </div>
    </div>
</body>
</html>
